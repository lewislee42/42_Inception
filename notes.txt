
things they want us to do in this project
install a vm to run the docker
the containers must be built using the penultimate stable version for either Alpine or Debian
write one docker file per service

you have to set up
a docker container that contains NGINX TLSv (1.2 or 1.3 only)
a docker container that contains WordPress + php-fpm (must be installed and configured) (without nginx)
a docker container that contains MariaDB (without nginx)
a docker volume that contains WordPress database
a docker volume that contains WordPress website files
a docker network to connecting everything together

(docker containers have to restart if a crash happens)
read about PID 1 and the best practices for writing dockerfiles
in the wordpress volume must be 2 users where 1 of them is a admin (Disclaimer: you cannot have the word admin in any of the users name)

# NOT ALLOWED
  the latest tag is not allowed
  no password should be in your dockerfiles
  it is forbidden to pull ready made docker images

it is mandotory to use environmental variables (use env)
use docker secrets if possible

  dockerfile must be called from the docker compose file by your makefile (needs clarification) (make file to docker compose)
(CAUTION 1 NEED CLARIFICATION)
  Of course, using network:  host or --link or links:  is forbidden.
  The network line must be present in your docker-compose.yml file.
  Your containers musn’t be started with a command running an infinite
  loop.  Thus, this also applies to any command used as entrypoint, or
  used in entrypoint scripts.  The following are a few prohibited hacky
  patches:  tail -f, bash, sleep infinity, while true.

(NEED CLARIFICATION)
  Your volumes will be available in the /home/login/data folder of the
  host machine using Docker.  Of course, you have to replace the login
  with yours.
  configure the domain name to point to you local ip address
  the domain name must be login.42.fr

(NEED CLARIFICATION)
  This domain name must be login.42.fr. Again, you have to use your own login.
  For example, if your login is wil, wil.42.fr will redirect to the IP address pointing to wil’s website.

(NEED CLARIFICATION)
  Your NGINX container must be the only entrypoint into your
  infrastructure via the port 443 only, using the TLSv1.2 or TLSv1.3
  protocol.


root@ce1aeea182e3:/# wp config create --dbname=$DB_NAME --dbuser=$DB_USER --dbpass=$DB_PASS --dbhost=mariadb --path=/var/www/html/ --allow-root
PHP Warning:  file_get_contents(phar://wp-cli.phar/vendor/wp-cli/wp-cli/templates/phar://usr/local/bin/wp/vendor/wp-cli/config-command/templates/wp-config.mustache): failed to open stream: phar error: "vendor/wp-cli/wp-cli/templates/phar:/usr/local/bin/wp/vendor/wp-cli/config-command/templates/wp-config.mustache" is not a file in phar "wp-cli.phar" in phar:///usr/local/bin/wp/vendor/wp-cli/wp-cli/php/utils.php on line 607

What’s Missing or Needs Adding

SSL/TLS Essentials:
Certificates: NGINX needs SSL certificates (public key and private key) to enable HTTPS. Without them, TLS won’t work, and 443 will fail.
Add: Settings to specify certificate file paths (e.g., ssl_certificate and ssl_certificate_key).
Why: Defines the encryption keys for TLSv1.2/1.3.
SSL on Listen: The listen directive needs ssl to activate TLS.
Adjust: Change to include ssl (e.g., listen 443 ssl;).
Why: Ensures NGINX uses SSL/TLS on 443.
Proper Proxy Configuration:
Target Definition: proxy_pass wordpress; is vague—NGINX needs a specific endpoint (e.g., http://wordpress:9000) matching your WordPress container’s PHP-FPM port.
Add/Adjust: Define the proxy target with the correct scheme (HTTP) and port (9000), reflecting your wordpress service.
Why: Ensures requests reach PHP-FPM correctly.
Proxy Headers: Basic proxying might work, but WordPress needs additional headers (e.g., Host, URI) for proper routing.
Add: Directives to pass essential headers (e.g., proxy_set_header for Host, X-Real-IP).
Why: Helps WordPress process requests as if directly accessed.
Blocking Other Ports:
Docker-Level: This config only listens on 443, but doesn’t block 80 explicitly. If port 80 is exposed elsewhere (e.g., another server block or Docker mapping), it’s still open.
Add: A separate block to redirect 80 to 443, or ensure Docker exposes only 443.
Why: Enforces “443-only” at the application level.
Host-Level: Relies on Docker or host firewall to block other ports (e.g., 80, 9000).
Ensure: No other ports are mapped in Docker Compose for NGINX.
WordPress-Specific Handling:
PHP Files: This setup proxies everything to WordPress, but WordPress uses PHP-FPM for .php files and serves static files directly (e.g., CSS, images).
Add: A location block to handle .php files specifically (like your prior config), or adjust proxy_pass to an upstream that differentiates.
Why: Ensures static assets aren’t unnecessarily proxied.
Root Directory: No root defined—static files need a base path (e.g., /var/www/wordpress-site).
Add: A root directive if serving static content alongside proxying.
Security and Optimization:
Cipher Suites: TLSv1.2/1.3 work better with modern ciphers for security and speed.
Add: A setting to define preferred ciphers (e.g., ssl_ciphers).
Why: Enhances TLS security.
HTTP/2: TLSv1.3 pairs well with HTTP/2 for performance.
Add: Enable HTTP/2 on the listen directive (e.g., listen 443 ssl http2;).
Why: Boosts speed for HTTPS traffic.
Error Handling:
404 Fallback: No fallback if proxying fails (e.g., WordPress container down).
Add: A try_files or error page directive as a backup.
Why: Improves user experience on failure.

REMINDER TO CLEAR SECRETS FILE

server_name *.42.fr;

    This wildcard means the server block applies to any subdomain of 42.fr (e.g., blog.42.fr, www.42.fr). Ensure your SSL certificate (/cert.pem) is a wildcard certificate covering *.42.fr, or this won’t work.


Test the Config: Run nginx -t to validate syntax before reloading.
WordPress-Specific Location Blocks: For better performance, add rules to serve static files directly instead of proxying to WordPress:
text
location ~* \.(jpg|jpeg|png|gif|ico|css|js|woff2?|ttf|svg|eot)$ {
    root /path/to/wordpress;
    expires 30d;
}

things we have to tackle
domain name does not work cause we need the hosts sudo permissions for changing the host network file to alias lewis.42.fr to localhost

we are getting file not found when entering the website:


It looks like you've shared an error log from a web server, likely Nginx, given the format and terminology (e.g., `FastCGI`, `upstream`). Let’s break this down and figure out what’s going on.

### Error Breakdown
The error message is:
```
"Primary script unknown" while reading response header from upstream
```
This typically occurs in a setup where Nginx is acting as a reverse proxy, forwarding requests to a FastCGI server (e.g., PHP-FPM) to process dynamic content. The FastCGI server, in this case running at `172.18.0.4:9000`, couldn’t find the script it was supposed to execute.

#### Key Details:
- **Timestamp**: `2025/03/10 10:32:42` (matches the current date you provided: March 10, 2025).
- **Client IP**: `172.18.0.1` (likely a local or containerized network IP).
- **Server Name**: `lewis.42.fr` (the virtual host or domain being accessed).
- **Request**: `GET / HTTP/2.0` (a basic request for the root page).
- **Upstream**: `fastcgi://172.18.0.4:9000` (the FastCGI backend server).
- **Host**: `127.0.0.1` (localhost, possibly indicating a local development setup).

### What’s Happening?
The `"Primary script unknown"` error from PHP-FPM (assuming that’s the FastCGI service) means that Nginx passed a request to the FastCGI backend, but the backend couldn’t locate the script file (e.g., `index.php`) to process the request. This is often a configuration or file path issue.

### Possible Causes
1. **Missing or Misconfigured Script File**:
   - The root directory for `lewis.42.fr` might not have an `index.php` (or equivalent) file, or it’s not in the expected location.
   - The `SCRIPT_FILENAME` parameter passed by Nginx to FastCGI might be incorrect.

2. **Nginx Configuration Issue**:
   - The `fastcgi_param SCRIPT_FILENAME` directive in your Nginx config might be misconfigured, pointing to a nonexistent file or directory.
   - Example of a typical config snippet:
     ```
     location ~ \.php$ {
         fastcgi_pass 172.18.0.4:9000;
         fastcgi_param SCRIPT_FILENAME /var/www/html/$fastcgi_script_name;
         include fastcgi_params;
     }
     ```
     If `/var/www/html/` (or your document root) doesn’t match the actual file location, you’ll get this error.

3. **File Permissions**:
   - The FastCGI process (e.g., PHP-FPM) might not have permission to access the script file or directory.

4. **Container or Network Misconfiguration**:
   - Since the IPs (`172.18.0.1`, `172.18.0.4`) suggest a Docker or similar containerized setup, there could be a mismatch between the Nginx container and the FastCGI container’s shared volumes or network settings.

### How to Fix It
Here’s a step-by-step troubleshooting guide:

1. **Check the Document Root**:
   - Look at your Nginx configuration (e.g., `/etc/nginx/sites-available/lewis.42.fr`) and find the `root` directive. Verify that the directory (e.g., `/var/www/html`) contains the expected script (e.g., `index.php`).

2. **Verify FastCGI Parameters**:
   - Ensure the `fastcgi_param SCRIPT_FILENAME` is correctly set. For example:
     ```
     fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
     ```
   - Check that `$document_root` resolves to the right path.

3. **Test the File Existence**:
   - Log into the FastCGI container (`172.18.0.4`) or server and confirm the script exists. For example:
     ```
     ls -l /var/www/html/index.php
     ```
   - If it’s missing, create a simple `index.php` with `<?php phpinfo();` to test.

4. **Check Permissions**:
   - Ensure the file and directory are readable by the FastCGI process user (often `www-data` or similar):
     ```
     chown www-data:www-data /var/www/html/index.php
     chmod 644 /var/www/html/index.php
     ```

5. **Restart Services**:
   - After making changes, restart Nginx and PHP-FPM:
     ```
     systemctl restart nginx
     systemctl restart php-fpm  # or php7.4-fpm, depending on version
     ```

6. **Debugging**:
   - Add `fastcgi_param` logging or enable more detailed PHP-FPM logs to see what file path it’s trying to access. Check `/var/log/php-fpm.log` or similar.

### Example Fix
If your Nginx config looks like this:
```
server {
    listen 80;
    server_name lewis.42.fr;
    root /var/www/html;
    index index.php;

    location / {
        try_files $uri $uri/ /index.php?$args;
    }

    location ~ \.php$ {
        fastcgi_pass 172.18.0.4:9000;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
```
- Ensure `/var/www/html/index.php` exists.
- Test with `curl http://lewis.42.fr` or a browser.

### Need More Help?
If you share your Nginx config or more context (e.g., are you using Docker?), I can refine the solution further. Let me know!

https://www.google.com/search?client=firefox-b-e&channel=entpr&q=400+Bad+Request+The+plain+HTTP+request+was+sent+to+HTTPS+port


have to connect using https://localhost:443 for now but running into errors of page not found
